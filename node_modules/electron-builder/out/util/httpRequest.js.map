{
  "version": 3,
  "file": "httpRequest.js",
  "sourceRoot": "",
  "sources": [
    "../../src/util/httpRequest.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { Socket } from \"net\"\nimport { IncomingMessage, ClientRequest } from \"http\"\nimport * as https from \"https\"\nimport { createWriteStream, ensureDir } from \"fs-extra-p\"\nimport { parse as parseUrl } from \"url\"\nimport { Promise as BluebirdPromise } from \"bluebird\"\nimport * as path from \"path\"\nimport { createHash } from \"crypto\"\nimport { Transform } from \"stream\"\n\nconst maxRedirects = 10\n\nexport interface DownloadOptions {\n  skipDirCreation?: boolean\n  sha2?: string\n}\n\nexport const download = <(url: string, destination: string, options?: DownloadOptions) => BluebirdPromise<any>>(BluebirdPromise.promisify(_download))\n\nfunction _download(url: string, destination: string, options: DownloadOptions | null | undefined, callback: (error: Error) => void): void {\n  if (callback == null) {\n    callback = <any>options\n    options = null\n  }\n  doDownload(url, destination, 0, options || {}, callback)\n}\n\nexport function addTimeOutHandler(request: ClientRequest, callback: (error: Error) => void) {\n  request.on(\"socket\", function (socket: Socket) {\n    socket.setTimeout(60 * 1000, () => {\n      callback(new Error(\"Request timed out\"))\n      request.abort()\n    })\n  })\n}\n\nfunction doDownload(url: string, destination: string, redirectCount: number, options: DownloadOptions, callback: (error: Error | null) => void) {\n  const ensureDirPromise = options.skipDirCreation ? BluebirdPromise.resolve() : ensureDir(path.dirname(destination))\n\n  const parsedUrl = parseUrl(url)\n  // user-agent must be specified, otherwise some host can return 401 unauthorised\n  const request = https.request({\n    hostname: parsedUrl.hostname,\n    path: parsedUrl.path,\n    headers: {\n      \"User-Agent\": \"electron-builder\"\n    }\n  }, (response: IncomingMessage) => {\n    if (response.statusCode >= 400) {\n      callback(new Error(`Cannot download \"${url}\", status ${response.statusCode}: ${response.statusMessage}`))\n      return\n    }\n\n    const redirectUrl = response.headers.location\n    if (redirectUrl != null) {\n      if (redirectCount < maxRedirects) {\n        doDownload(redirectUrl, destination, redirectCount++, options, callback)\n      }\n      else {\n        callback(new Error(\"Too many redirects (> \" + maxRedirects + \")\"))\n      }\n      return\n    }\n\n    const sha2Header = response.headers[\"X-Checksum-Sha2\"]\n    if (sha2Header != null && options.sha2 != null) {\n      // todo why bintray doesn't send this header always\n      if (sha2Header == null) {\n        throw new Error(\"checksum is required, but server response doesn't contain X-Checksum-Sha2 header\")\n      }\n      else if (sha2Header !== options.sha2) {\n        throw new Error(`checksum mismatch: expected ${options.sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`)\n      }\n    }\n\n    ensureDirPromise\n      .then(() => {\n        const fileOut = createWriteStream(destination)\n        if (options.sha2 == null) {\n          response.pipe(fileOut)\n        }\n        else {\n          response\n            .pipe(new DigestTransform(options.sha2))\n            .pipe(fileOut)\n        }\n\n        fileOut.on(\"finish\", callback)\n      })\n      .catch(callback)\n\n    let ended = false\n    response.on(\"end\", () => {\n      ended = true\n    })\n\n    response.on(\"close\", () => {\n      if (!ended) {\n        callback(new Error(\"Request aborted\"))\n      }\n    })\n  })\n  addTimeOutHandler(request, callback)\n  request.on(\"error\", callback)\n  request.end()\n}\n\nclass DigestTransform extends Transform {\n  readonly digester = createHash(\"sha256\")\n\n  constructor(private expected: string) {\n   super()\n  }\n\n  _transform(chunk: any, encoding: string, callback: Function) {\n    this.digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush(callback: Function): void {\n    const hash = this.digester.digest(\"hex\")\n    callback(hash === this.expected ? null : new Error(`SHA2 checksum mismatch, expected ${this.expected}, got ${hash}`))\n  }\n}"
  ]
}
