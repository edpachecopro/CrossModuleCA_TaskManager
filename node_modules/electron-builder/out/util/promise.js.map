{
  "version": 3,
  "file": "promise.js",
  "sourceRoot": "",
  "sources": [
    "../../src/util/promise.ts"
  ],
  "names": [],
  "mappings": ";;AAAA,2BAA2C,AAAU,AACrD,AAAC;AAAD,wBAAoB,AAAO,AAG3B,AAAC;AADD,AAAmC;AACnC,MAAM,AAAS,YAAG,AAAO,QAAC,AAAW,AAAC;AAEtC,2BAAkC,AAAY;AAC5C,AAAO,YAAC,AAAK,MAAC,QAAG,IAAC,CAAC,AAAK,MAAC,AAAK,SAAI,AAAK,AAAC,OAAC,AAAQ,AAAE,AAAC,AAAC;AACrD,AAAO,YAAC,AAAI,KAAC,CAAC,AAAC,AAAC,AAClB;AAAC;AAHe,QAAiB,oBAGhC;AAED,AAA6F;AAC7F,wBAAwC,AAAmB,SAAE,AAA8C;;AACzG,YAAI,AAAM,SAAa,AAAI;AAC3B,YAAI,AAAC;AACH,AAAM,qBAAG,MAAM,AAAO,AACxB;AACA,UAAA,AAAK,AAAC,OAAC,AAAa,AAAC,eAAC,AAAC;AACrB,gBAAI,AAAC;AACH,sBAAM,AAAI,KAAC,AAAI,AAAC,AAClB;AACA,cAAA,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,sBAAM,IAAI,AAAW,YAAC,CAAC,AAAa,eAAE,AAAS,AAAC,AAAC,AACnD;AAAC;AAED,kBAAM,AAAa,AACrB;AAAC;AAED,YAAI,AAAC;AACH,kBAAM,AAAI,KAAC,AAAK,AAAC,AACnB;AACA,UAAA,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,kBAAM,AAAS,AACjB;AAAC;AACD,AAAM,eAAC,AAAM,AACf;AAAC;;AAvBqB,QAAc,iBAuBnC;AAED,0BAAiC,AAAK;AACpC,gBAAY,AAAoB;YAAE,AAAO,gEAAW,AAAkB;;AACpE,YAAI,AAAC,IAAG,AAAO;AACf,YAAI,AAAC,IAAG,AAAC;AACT,AAAG,AAAC,aAAC,IAAI,AAAK,SAAI,AAAM,AAAC,QAAC,AAAC;AACzB,kBAAM,AAAM,SAAG,AAAS,YAAG,AAAC,AAAE,MAAG,AAAG;AACpC,AAAC,iBAAI,AAAM,SAAG,AAAM,SAAG,AAAG,IAAC,AAAM,OAAC,AAAE,AAAC,MAAG,AAAI,OAAG,AAAM,MAAC,AAAK,AAC7D;AAAC;AACD,cAAM,AAAC,AAAC,AACV;AAAC,AACH,AAAC;;AAVY,QAAW,cAUvB;AAED,aAAoB,AAA6B;AAC/C,UAAM,AAAM,SAAiB,AAAE;AAC/B,AAAM,sBAAgB,QAAC,AAAG,IAAC,AAAQ,SAAC,AAAG,IAAC,AAAE,MAAI,AAAE,GAAC,AAAK,MAAC,AAAE,MAAI,AAAM,OAAC,AAAI,KAAC,AAAE,AAAC,AAAC,AAAC,AAAC,OAC5E,AAAI,KAAC;AACJ,AAAE,AAAC,YAAC,AAAM,OAAC,AAAM,WAAK,AAAC,AAAC,GAAC,AAAC;AACxB,kBAAM,AAAM,OAAC,AAAC,AAAC,AACjB;AAAC,AACD,AAAI,eAAC,AAAE,AAAC,IAAC,AAAM,OAAC,AAAM,SAAG,AAAC,AAAC,GAAC,AAAC;AAC3B,kBAAM,IAAI,AAAW,YAAC,AAAM,QAAE,AAAkB,AAAC,AACnD;AAAC,AACH;AAAC,AAAC,AACN,KATS;AASR;AAXe,QAAG,MAWlB",
  "sourcesContent": [
    "import { Promise as BluebirdPromise } from \"bluebird\"\nimport { red } from \"chalk\"\n\n//noinspection JSUnusedLocalSymbols\nconst __awaiter = require(\"./awaiter\")\n\nexport function printErrorAndExit(error: Error) {\n  console.error(red((error.stack || error).toString()))\n  process.exit(-1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally<T>(promise: Promise<T>, task: (errorOccurred: boolean) => Promise<any>): Promise<T> {\n  let result: T | null = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(true)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  try {\n    await task(false)\n  }\n  catch (taskError) {\n    throw taskError\n  }\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (let error of errors) {\n      const prefix = \"Error #\" + i++ + \" \"\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\n    }\n    super(m)\n  }\n}\n\nexport function all(promises: Array<Promise<any>>): BluebirdPromise<any> {\n  const errors: Array<Error> = []\n  return BluebirdPromise.all(promises.map(it => it.catch(it => errors.push(it))))\n    .then(() => {\n      if (errors.length === 1) {\n        throw errors[0]\n      }\n      else if (errors.length > 1) {\n        throw new NestedError(errors, \"Cannot cleanup: \")\n      }\n    })\n}"
  ]
}
